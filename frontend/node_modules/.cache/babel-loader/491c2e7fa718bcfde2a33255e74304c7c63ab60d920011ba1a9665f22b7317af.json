{"ast":null,"code":"// Geolocation Service for Tourist Safety System\nclass GeolocationService {\n  constructor() {\n    this.watchId = null;\n    this.currentPosition = null;\n    this.options = {\n      enableHighAccuracy: true,\n      timeout: 10000,\n      maximumAge: 60000 // 1 minute\n    };\n  }\n\n  // Get current position\n  async getCurrentPosition() {\n    return new Promise((resolve, reject) => {\n      if (!navigator.geolocation) {\n        reject(new Error('Geolocation is not supported by this browser'));\n        return;\n      }\n      navigator.geolocation.getCurrentPosition(position => {\n        this.currentPosition = {\n          lat: position.coords.latitude,\n          lng: position.coords.longitude,\n          accuracy: position.coords.accuracy,\n          timestamp: new Date()\n        };\n        resolve(this.currentPosition);\n      }, error => {\n        reject(this.handleLocationError(error));\n      }, this.options);\n    });\n  }\n\n  // Start watching position\n  startWatching(callback, errorCallback) {\n    if (!navigator.geolocation) {\n      errorCallback(new Error('Geolocation is not supported'));\n      return;\n    }\n    this.watchId = navigator.geolocation.watchPosition(position => {\n      this.currentPosition = {\n        lat: position.coords.latitude,\n        lng: position.coords.longitude,\n        accuracy: position.coords.accuracy,\n        timestamp: new Date()\n      };\n      callback(this.currentPosition);\n    }, error => {\n      errorCallback(this.handleLocationError(error));\n    }, this.options);\n    return this.watchId;\n  }\n\n  // Stop watching position\n  stopWatching() {\n    if (this.watchId !== null) {\n      navigator.geolocation.clearWatch(this.watchId);\n      this.watchId = null;\n    }\n  }\n\n  // Handle location errors\n  handleLocationError(error) {\n    switch (error.code) {\n      case error.PERMISSION_DENIED:\n        return new Error('Location access denied by user');\n      case error.POSITION_UNAVAILABLE:\n        return new Error('Location information unavailable');\n      case error.TIMEOUT:\n        return new Error('Location request timed out');\n      default:\n        return new Error('An unknown location error occurred');\n    }\n  }\n\n  // Calculate distance between two points (Haversine formula)\n  calculateDistance(pos1, pos2) {\n    const R = 6371; // Earth's radius in kilometers\n    const dLat = this.toRadians(pos2.lat - pos1.lat);\n    const dLng = this.toRadians(pos2.lng - pos1.lng);\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(this.toRadians(pos1.lat)) * Math.cos(this.toRadians(pos2.lat)) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    const distance = R * c;\n    return distance; // Distance in kilometers\n  }\n\n  // Convert degrees to radians\n  toRadians(degrees) {\n    return degrees * (Math.PI / 180);\n  }\n\n  // Check if point is within a polygon (safety zone)\n  isPointInPolygon(point, polygon) {\n    let inside = false;\n    const x = point.lat;\n    const y = point.lng;\n    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n      const xi = polygon[i][0];\n      const yi = polygon[i][1];\n      const xj = polygon[j][0];\n      const yj = polygon[j][1];\n      if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {\n        inside = !inside;\n      }\n    }\n    return inside;\n  }\n\n  // Get nearest safety zone\n  getNearestSafetyZone(position, safetyZones) {\n    let nearestZone = null;\n    let minDistance = Infinity;\n    safetyZones.forEach(zone => {\n      // Calculate distance to zone center\n      const zoneCenter = this.calculatePolygonCenter(zone.coordinates);\n      const distance = this.calculateDistance(position, zoneCenter);\n      if (distance < minDistance) {\n        minDistance = distance;\n        nearestZone = {\n          ...zone,\n          distance: distance,\n          isInside: this.isPointInPolygon(position, zone.coordinates)\n        };\n      }\n    });\n    return nearestZone;\n  }\n\n  // Calculate polygon center (centroid)\n  calculatePolygonCenter(coordinates) {\n    let lat = 0;\n    let lng = 0;\n    coordinates.forEach(coord => {\n      lat += coord[0];\n      lng += coord[1];\n    });\n    return {\n      lat: lat / coordinates.length,\n      lng: lng / coordinates.length\n    };\n  }\n\n  // Format coordinates for display\n  formatCoordinates(position, precision = 6) {\n    if (!position || !position.lat || !position.lng) {\n      return 'Unknown location';\n    }\n    return `${position.lat.toFixed(precision)}, ${position.lng.toFixed(precision)}`;\n  }\n\n  // Get location permissions status\n  async getPermissionStatus() {\n    if (!navigator.permissions) {\n      return 'unknown';\n    }\n    try {\n      const permission = await navigator.permissions.query({\n        name: 'geolocation'\n      });\n      return permission.state; // 'granted', 'denied', or 'prompt'\n    } catch (error) {\n      return 'unknown';\n    }\n  }\n\n  // Request location permissions\n  async requestPermission() {\n    const status = await this.getPermissionStatus();\n    if (status === 'granted') {\n      return true;\n    } else if (status === 'denied') {\n      return false;\n    } else {\n      // Try to get location to trigger permission prompt\n      try {\n        await this.getCurrentPosition();\n        return true;\n      } catch (error) {\n        return false;\n      }\n    }\n  }\n\n  // Get address from coordinates (reverse geocoding simulation)\n  async getAddressFromCoordinates(lat, lng) {\n    // In a real app, you would use a geocoding service like Google Maps or OpenStreetMap\n    // For demo purposes, return a simulated address\n\n    // Famous locations in Delhi for demo\n    const delhiLocations = [{\n      lat: 28.6139,\n      lng: 77.2090,\n      address: 'India Gate, New Delhi'\n    }, {\n      lat: 28.6507,\n      lng: 77.2334,\n      address: 'Red Fort, Old Delhi'\n    }, {\n      lat: 28.5245,\n      lng: 77.1855,\n      address: 'Qutub Minar, Mehrauli'\n    }, {\n      lat: 28.6562,\n      lng: 77.2410,\n      address: 'Jama Masjid, Old Delhi'\n    }, {\n      lat: 28.6127,\n      lng: 77.2773,\n      address: 'Lotus Temple, Kalkaji'\n    }];\n\n    // Find closest known location\n    let closestLocation = delhiLocations[0];\n    let minDistance = this.calculateDistance({\n      lat,\n      lng\n    }, {\n      lat: closestLocation.lat,\n      lng: closestLocation.lng\n    });\n    delhiLocations.forEach(location => {\n      const distance = this.calculateDistance({\n        lat,\n        lng\n      }, {\n        lat: location.lat,\n        lng: location.lng\n      });\n      if (distance < minDistance) {\n        minDistance = distance;\n        closestLocation = location;\n      }\n    });\n\n    // If very close to a known location, return that address\n    if (minDistance < 0.5) {\n      // Within 500 meters\n      return closestLocation.address;\n    }\n\n    // Otherwise return generic address\n    return `Near ${closestLocation.address}`;\n  }\n\n  // Check if location services are available\n  isLocationServiceAvailable() {\n    return 'geolocation' in navigator;\n  }\n\n  // Get current position with enhanced error handling\n  async getEnhancedPosition() {\n    try {\n      const position = await this.getCurrentPosition();\n      const address = await this.getAddressFromCoordinates(position.lat, position.lng);\n      return {\n        ...position,\n        address,\n        formatted: this.formatCoordinates(position)\n      };\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  // Start background location tracking for safety monitoring\n  startSafetyTracking(callback, safetyZones) {\n    return this.startWatching(position => {\n      const nearestZone = this.getNearestSafetyZone(position, safetyZones);\n      callback({\n        position,\n        nearestZone,\n        timestamp: new Date()\n      });\n    }, error => {\n      console.error('Safety tracking error:', error);\n      callback({\n        error: error.message\n      });\n    });\n  }\n}\nexport const geolocationService = new GeolocationService();\nexport default geolocationService;","map":{"version":3,"names":["GeolocationService","constructor","watchId","currentPosition","options","enableHighAccuracy","timeout","maximumAge","getCurrentPosition","Promise","resolve","reject","navigator","geolocation","Error","position","lat","coords","latitude","lng","longitude","accuracy","timestamp","Date","error","handleLocationError","startWatching","callback","errorCallback","watchPosition","stopWatching","clearWatch","code","PERMISSION_DENIED","POSITION_UNAVAILABLE","TIMEOUT","calculateDistance","pos1","pos2","R","dLat","toRadians","dLng","a","Math","sin","cos","c","atan2","sqrt","distance","degrees","PI","isPointInPolygon","point","polygon","inside","x","y","i","j","length","xi","yi","xj","yj","getNearestSafetyZone","safetyZones","nearestZone","minDistance","Infinity","forEach","zone","zoneCenter","calculatePolygonCenter","coordinates","isInside","coord","formatCoordinates","precision","toFixed","getPermissionStatus","permissions","permission","query","name","state","requestPermission","status","getAddressFromCoordinates","delhiLocations","address","closestLocation","location","isLocationServiceAvailable","getEnhancedPosition","formatted","startSafetyTracking","console","message","geolocationService"],"sources":["C:/YatraSathi/tourist-safety-app/frontend/src/services/geolocation.js"],"sourcesContent":["// Geolocation Service for Tourist Safety System\r\nclass GeolocationService {\r\n  constructor() {\r\n    this.watchId = null;\r\n    this.currentPosition = null;\r\n    this.options = {\r\n      enableHighAccuracy: true,\r\n      timeout: 10000,\r\n      maximumAge: 60000 // 1 minute\r\n    };\r\n  }\r\n\r\n  // Get current position\r\n  async getCurrentPosition() {\r\n    return new Promise((resolve, reject) => {\r\n      if (!navigator.geolocation) {\r\n        reject(new Error('Geolocation is not supported by this browser'));\r\n        return;\r\n      }\r\n\r\n      navigator.geolocation.getCurrentPosition(\r\n        (position) => {\r\n          this.currentPosition = {\r\n            lat: position.coords.latitude,\r\n            lng: position.coords.longitude,\r\n            accuracy: position.coords.accuracy,\r\n            timestamp: new Date()\r\n          };\r\n          resolve(this.currentPosition);\r\n        },\r\n        (error) => {\r\n          reject(this.handleLocationError(error));\r\n        },\r\n        this.options\r\n      );\r\n    });\r\n  }\r\n\r\n  // Start watching position\r\n  startWatching(callback, errorCallback) {\r\n    if (!navigator.geolocation) {\r\n      errorCallback(new Error('Geolocation is not supported'));\r\n      return;\r\n    }\r\n\r\n    this.watchId = navigator.geolocation.watchPosition(\r\n      (position) => {\r\n        this.currentPosition = {\r\n          lat: position.coords.latitude,\r\n          lng: position.coords.longitude,\r\n          accuracy: position.coords.accuracy,\r\n          timestamp: new Date()\r\n        };\r\n        callback(this.currentPosition);\r\n      },\r\n      (error) => {\r\n        errorCallback(this.handleLocationError(error));\r\n      },\r\n      this.options\r\n    );\r\n\r\n    return this.watchId;\r\n  }\r\n\r\n  // Stop watching position\r\n  stopWatching() {\r\n    if (this.watchId !== null) {\r\n      navigator.geolocation.clearWatch(this.watchId);\r\n      this.watchId = null;\r\n    }\r\n  }\r\n\r\n  // Handle location errors\r\n  handleLocationError(error) {\r\n    switch (error.code) {\r\n      case error.PERMISSION_DENIED:\r\n        return new Error('Location access denied by user');\r\n      case error.POSITION_UNAVAILABLE:\r\n        return new Error('Location information unavailable');\r\n      case error.TIMEOUT:\r\n        return new Error('Location request timed out');\r\n      default:\r\n        return new Error('An unknown location error occurred');\r\n    }\r\n  }\r\n\r\n  // Calculate distance between two points (Haversine formula)\r\n  calculateDistance(pos1, pos2) {\r\n    const R = 6371; // Earth's radius in kilometers\r\n    const dLat = this.toRadians(pos2.lat - pos1.lat);\r\n    const dLng = this.toRadians(pos2.lng - pos1.lng);\r\n\r\n    const a = \r\n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n      Math.cos(this.toRadians(pos1.lat)) * Math.cos(this.toRadians(pos2.lat)) *\r\n      Math.sin(dLng / 2) * Math.sin(dLng / 2);\r\n\r\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n    const distance = R * c;\r\n\r\n    return distance; // Distance in kilometers\r\n  }\r\n\r\n  // Convert degrees to radians\r\n  toRadians(degrees) {\r\n    return degrees * (Math.PI / 180);\r\n  }\r\n\r\n  // Check if point is within a polygon (safety zone)\r\n  isPointInPolygon(point, polygon) {\r\n    let inside = false;\r\n    const x = point.lat;\r\n    const y = point.lng;\r\n\r\n    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\r\n      const xi = polygon[i][0];\r\n      const yi = polygon[i][1];\r\n      const xj = polygon[j][0];\r\n      const yj = polygon[j][1];\r\n\r\n      if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {\r\n        inside = !inside;\r\n      }\r\n    }\r\n\r\n    return inside;\r\n  }\r\n\r\n  // Get nearest safety zone\r\n  getNearestSafetyZone(position, safetyZones) {\r\n    let nearestZone = null;\r\n    let minDistance = Infinity;\r\n\r\n    safetyZones.forEach(zone => {\r\n      // Calculate distance to zone center\r\n      const zoneCenter = this.calculatePolygonCenter(zone.coordinates);\r\n      const distance = this.calculateDistance(position, zoneCenter);\r\n\r\n      if (distance < minDistance) {\r\n        minDistance = distance;\r\n        nearestZone = {\r\n          ...zone,\r\n          distance: distance,\r\n          isInside: this.isPointInPolygon(position, zone.coordinates)\r\n        };\r\n      }\r\n    });\r\n\r\n    return nearestZone;\r\n  }\r\n\r\n  // Calculate polygon center (centroid)\r\n  calculatePolygonCenter(coordinates) {\r\n    let lat = 0;\r\n    let lng = 0;\r\n\r\n    coordinates.forEach(coord => {\r\n      lat += coord[0];\r\n      lng += coord[1];\r\n    });\r\n\r\n    return {\r\n      lat: lat / coordinates.length,\r\n      lng: lng / coordinates.length\r\n    };\r\n  }\r\n\r\n  // Format coordinates for display\r\n  formatCoordinates(position, precision = 6) {\r\n    if (!position || !position.lat || !position.lng) {\r\n      return 'Unknown location';\r\n    }\r\n\r\n    return `${position.lat.toFixed(precision)}, ${position.lng.toFixed(precision)}`;\r\n  }\r\n\r\n  // Get location permissions status\r\n  async getPermissionStatus() {\r\n    if (!navigator.permissions) {\r\n      return 'unknown';\r\n    }\r\n\r\n    try {\r\n      const permission = await navigator.permissions.query({ name: 'geolocation' });\r\n      return permission.state; // 'granted', 'denied', or 'prompt'\r\n    } catch (error) {\r\n      return 'unknown';\r\n    }\r\n  }\r\n\r\n  // Request location permissions\r\n  async requestPermission() {\r\n    const status = await this.getPermissionStatus();\r\n\r\n    if (status === 'granted') {\r\n      return true;\r\n    } else if (status === 'denied') {\r\n      return false;\r\n    } else {\r\n      // Try to get location to trigger permission prompt\r\n      try {\r\n        await this.getCurrentPosition();\r\n        return true;\r\n      } catch (error) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Get address from coordinates (reverse geocoding simulation)\r\n  async getAddressFromCoordinates(lat, lng) {\r\n    // In a real app, you would use a geocoding service like Google Maps or OpenStreetMap\r\n    // For demo purposes, return a simulated address\r\n\r\n    // Famous locations in Delhi for demo\r\n    const delhiLocations = [\r\n      { lat: 28.6139, lng: 77.2090, address: 'India Gate, New Delhi' },\r\n      { lat: 28.6507, lng: 77.2334, address: 'Red Fort, Old Delhi' },\r\n      { lat: 28.5245, lng: 77.1855, address: 'Qutub Minar, Mehrauli' },\r\n      { lat: 28.6562, lng: 77.2410, address: 'Jama Masjid, Old Delhi' },\r\n      { lat: 28.6127, lng: 77.2773, address: 'Lotus Temple, Kalkaji' }\r\n    ];\r\n\r\n    // Find closest known location\r\n    let closestLocation = delhiLocations[0];\r\n    let minDistance = this.calculateDistance({ lat, lng }, { lat: closestLocation.lat, lng: closestLocation.lng });\r\n\r\n    delhiLocations.forEach(location => {\r\n      const distance = this.calculateDistance({ lat, lng }, { lat: location.lat, lng: location.lng });\r\n      if (distance < minDistance) {\r\n        minDistance = distance;\r\n        closestLocation = location;\r\n      }\r\n    });\r\n\r\n    // If very close to a known location, return that address\r\n    if (minDistance < 0.5) { // Within 500 meters\r\n      return closestLocation.address;\r\n    }\r\n\r\n    // Otherwise return generic address\r\n    return `Near ${closestLocation.address}`;\r\n  }\r\n\r\n  // Check if location services are available\r\n  isLocationServiceAvailable() {\r\n    return 'geolocation' in navigator;\r\n  }\r\n\r\n  // Get current position with enhanced error handling\r\n  async getEnhancedPosition() {\r\n    try {\r\n      const position = await this.getCurrentPosition();\r\n      const address = await this.getAddressFromCoordinates(position.lat, position.lng);\r\n\r\n      return {\r\n        ...position,\r\n        address,\r\n        formatted: this.formatCoordinates(position)\r\n      };\r\n    } catch (error) {\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Start background location tracking for safety monitoring\r\n  startSafetyTracking(callback, safetyZones) {\r\n    return this.startWatching(\r\n      (position) => {\r\n        const nearestZone = this.getNearestSafetyZone(position, safetyZones);\r\n        callback({\r\n          position,\r\n          nearestZone,\r\n          timestamp: new Date()\r\n        });\r\n      },\r\n      (error) => {\r\n        console.error('Safety tracking error:', error);\r\n        callback({ error: error.message });\r\n      }\r\n    );\r\n  }\r\n}\r\n\r\nexport const geolocationService = new GeolocationService();\r\nexport default geolocationService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}